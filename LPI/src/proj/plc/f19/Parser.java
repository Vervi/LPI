package proj.plc.f19;

import java.util.*;

public class Parser {
    private HashMap<String, Integer> memory;
    private Lexer.Token input;
    private Iterator<Lexer.Token> itr;
    private LinkedList<Lexer.Token> tokens;
    private String current; //points to the token currently being looked at by the parser
    private String var; //the variable currently being worked on by the interpreter (ID on left side of assignment fn)
   // private String current_op;
   // private Boolean parCheck = false; //check to see if parser is interpreting tokens inside a parenthentical expression
    private int v1;
    private int v2;
    private String t_type;

    private int t = 0; //the value associated with temp in memory map
    private String temp = "temp";
    private int p = 0; //the value associated with what's inside current parenthitecal operation in memory map
    private String par = "par";

    Stack<Character> ops;
    Stack<Integer> operands;
    Stack<String> postfix;
   // String[] operators = new[]{""};

    /**
     * Constructor of parser
     */
    public Parser(){

    }
    //for readability referring to tokens by type name
    private void match(String expected) {
        if (!(input.name.equals(expected))) {
            parseError();
        } else
            next();
    }

    /**
     * An exception generated by an error in parsing. Method is called when an unexpected token appears in the stream.
     */
    private void parseError() {
        throw new ParseException("we weren't expecting to see " + input.token + " here.");
    }

    /**
     * An exception generated by an error in interpretation. Method is called when operations are done on variables that cannot be resolved.
     */
    private void interpretorError() {
        throw new ParseException("unable to interpret variable '" + input.token + "', it is undefined.");
    }

    /**
     * A simple function that creates an iterator for the list of tokens to be interpreted and
     * a hashmap to store intermediary computations. It initiates a call to the parser's start rule.
     */

    void parse(LinkedList<Lexer.Token> tkns) {
        this.tokens=tkns;
        itr = tokens.iterator();
        ops =new Stack<>();
        operands= new Stack<>();
       // operands =new Stack<>();

        next();
        memory = new HashMap<String, Integer>();
        memory.put(temp, t);
        memory.put(par, p);
        program();
    }

    void next() {
        try {
            if (itr.hasNext()) {
                input = itr.next();
                current = input.token.intern();
                t_type = input.name;
            }
        } catch (NoSuchElementException e) {
            input = null;
        }
    }

    /**
     * Start rule of the defined grammar.
     */
    void program() {
       //  System.out.println("entering start rule: 'program'...");

        while (!(t_type.equals("eoi"))) { //as long as $ has not been reached keep looping
            switch (t_type) {
                case "Identifier":
                    assignment();
                    break;
                default:
                    parseError();
            }
        }

        //    if any key in the map is set to null then we need to throw an error and not print anything
        if(memory.containsValue(null))
            interpretorError();
        else {
             memory.remove(temp);
             memory.remove(par);
             memory.entrySet().forEach(entry -> {
                System.out.println(entry.getKey() + " = " + entry.getValue());
            });
        }
    }

    private void assignment() {
        //  System.out.println("enter assignment...");
        switch (t_type) {
            case "Identifier":
                memory.put(current, null); //add variable name to memory
                var = current;
                match("Identifier");
               // operands.add('id');
                match("Equals");
               // current_op = "eq";
                ops.add('=');
                expr();
                match("Semi");
                ops.add(';');
                break;
            default:
                parseError();
        }
       //      System.out.println("assignment ended");
    }

    private void expr() {
        //    System.out.println("enter expr...");
        switch (t_type) {
            case "L_Par":
            case "Minus":
            case "Plus":
            case "Literal":
            case "Identifier":
                //exprNode.left=term(); exprNode.right=
                term();
                expr_pr();
                memory.put(var, memory.get(temp));
                break;
            default:
                parseError();
        }
       // System.out.println("expr ended");
    }

    private void expr_pr() {
       //  System.out.println("enter expr_pr...");
        switch (t_type) {
            case "Plus":
                match("Plus");
           //   exprNode.token="+"; exprNode.left=term(); exprNode.right=expr_pr();
                term();
                expr_pr();
                break;
            case "Minus":
                match("Minus");
           //   exprNode.token="+"; exprNode.left=term(); exprNode.right=expr_pr();
                term();
                expr_pr();

                break;
            case "R_Par":
            case "Semi":
            case "WS":
                break;
            default:
                parseError();
        }
        //System.out.println("expr_pr ended");
    }

    private void term() {
        //System.out.println("enter term....");
        switch (t_type) {
            case "Plus":
        //     termNode.token="+"; termNode.left=fact(); termNode.right=term_pr();
                fact();
                term_pr();
                break;
            case "Minus":
        //     termNode.token="+"; termNode.left=fact(); termNode.right=term_pr();
                fact();
                term_pr();
                break;

            case "L_Par":
            case "Literal":
            case "Identifier":
                //     termNode.token="+"; termNode.left=fact(); termNode.right=term_pr();
                fact();
                term_pr();
                break;

            default:
                parseError();

        }
    }

    private void term_pr() {
        // System.out.println("enter term_pr...");
        switch (t_type) {
            case "Mul": //6
         //       current_op = "Mul";
                ops.add('*');
                match("Mul");
                fact();
               // last_op = current_op;
                term_pr();
                break; //may need to remove this one
            case "Plus": //+
            case "Minus": //-
            case "R_Par": //)
            case "Semi": //;
                break;
            default:
                parseError();
        }
       // System.out.println("term_pr ended");
    }

    //String last_op = "";

    private void fact() {
        //System.out.println("enter fact...");
        switch (t_type) {
            case "L_Par": //(
               // last_op = current_op;
              //  current_op = "L_Par";
                ops.add('(');
                //   parCheck = true;
                match("L_Par");
                //factNode=expr();
                expr();
               // parCheck = false;
                ops.add(')');
                match("R_Par"); //)
                //if prev match succeeded, no longer inside (exp)
               // last_op = "R_Par";
                break;
            case "Minus": //-
               // current_op = "Minus";
                ops.add('-');
                //factNode.token="-"; factNode.left=fact();
                match("Minus");
                //last_op = current_op;
                fact();
                break;
            case "Plus": //+
               // current_op = "Plus";
                ops.add('+');
                //factNode.token="-"; factNode.left=fact();
                match("Plus");
                //last_op = current_op;
                fact();
                break;
            case "Literal": //lit
                v1 = Integer.parseInt(current);
               // update();
                //factNode.token=current;
                operands.add(v1);
                match("Literal");
                break;
            case "Identifier":
                //  System.out.println("fact id input token is : "+ current +'\n' + " value: "+ memory.get(current));
                if (memory.containsKey(current) && (memory.get(current) != null)) {
                    v1 = memory.get(current);
                    //factNode.token=current;
                    //update();
                    operands.add(v1);
                }
                else
                {
                    interpretorError();
                }
                //ops.add("id");
                match("Identifier");
                break;
            default:
                parseError();
        }
        //System.out.println("fact ended");
    }






}
